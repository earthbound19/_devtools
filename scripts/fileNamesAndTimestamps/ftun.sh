# DESCRIPTION
# FTUN stands for "Fix Terminal Unfriendly [folder and file] Names." This script does just that by building a proposed mv command shell script for every folder and file name under the path from which this script is executed.

# USAGE
# From a terminal, in a folder with terminal-processing-unfriendly names, execute this script and follow the prompts.

# TO DO
# Use the elegant means I found somewhere of eliminating lines that are identical between alles and alles2.txt etc. (as this would avoid time-wasting and error-trowing renames of a file to itself) before further marking up and pasting them.

# === FOLDERS RENAMING ===
find * -type d > alles.txt
# Build first part of mv command in .sh file:
sed -i "s/\(.*\)/mv '\1'/" alles.txt
# Build second part of move command by replacing all terminal-unfriendly characters in listed folder names, via tr:
find * -type d | tr \=\'\@\`~\!#$%^\&\(\)+[{]}\;\ ,- _ > alles2.txt
				# Example bad folder name that was tested against:
				# WUT`'''''~!@#$%^&a()-=hi hi HEY+[{]};' ,
# Prune all triplicate+ underscores to double (for target folder names) :
sed -i "s/_\{3,\}/__/g" alles2.txt
sed -i "s/\(.*\)/ '\1'/" alles2.txt
# Join the two via paste, with the -d '' parameter meaning "don't use any delimiters between pasted items:"
paste -d '' alles.txt alles2.txt > badPathsRename.sh.txt
rm alles.txt alles2.txt

echo !=======================!
echo \! WARNING \! AND NOTE\: This rename script may choke and fail or cause DRASTICALLY WRONG file renames IF ANY folders and files have single-quote marks \(\'\)\ in their name \(never put that in a file name--that\'s terminal-unfriendly\)\. You will want to take care of those via the free FlexibleRenamer.exe or metamorphose utilities\; for the latter\, with noQuotes.cfg. PROGRAMMER TO DO\: Clarify that by elaborating on it.
echo !=======================!
echo DONE creating proposed folder rename script. Examine badPathsRename.sh.txt\, and if the proposed mv \(rename\) commands in it all look good\, press y\, and I will rename that \.txt file to a \.sh script and execute it\, to actually do the renames.
read -r -p "Are you sure? [y/N] " response
case $response in
    [yY][eE][sS]|[yY]) 
        echo Dokee-okee! Working . . .;
        ;;
    *)
        echo D\'oh! Terminating script.; exit;
        ;;
esac

mv badPathsRename.sh.txt badPathsRename.sh
./badPathsRename.sh
# === FILES RENAMING ===
# DO all of the same things again, but for files only (now that paths have been fixed up, eliminating problems that would otherwise cause in path renaming, and because fixing paths at the same time as files would mean wasted and error-throwing duplicate path rename commands.)

# Without some "do not match" search conditions in find commands, the alles3.txt and alles4.txt files which would be generated by the following commands will show up in the list files, and drastically mess up renaming!
shopt -s extglob
find !(alles*.txt) -type f > alles3.txt
	# find * -type f > alles3.txt
sed -i "s/\(.*\)/mv '\1'/" alles3.txt
find !(alles*.txt) -type f | tr \=\'\@\`~\!#$%^\&\(\)+[{]}\;\ ,- _ > alles4.txt
sed -i "s/_\{3,\}/__/g" alles4.txt
sed -i "s/\(.*\)/ '\1'/" alles4.txt
paste -d '' alles3.txt alles4.txt > badFilesRename.sh.txt
rm alles3.txt alles4.txt

echo
echo DONE creating proposed file rename script. Examine badFilesRename.sh.txt\, and if the proposed mv \(rename\) commands in it all look good\, press y\, and I will rename that \.txt file to a \.sh script and execute it\, to actually do the renames. NOTE: This rename script may choke and fail on file names that include single-quote marks \(\'\)\. You will want to take care of those via the free FlexibleRenamer.exe or metamorphose utilities\; for the latter\, with noQuotes.cfg. PROGRAMMER TO DO\: Clarify that by elaborating on it.
read -r -p "Are you sure? [y/N] " response
case $response in
    [yY][eE][sS]|[yY]) 
        echo Dokee-okee! Working . . .;
        ;;
    *)
        echo D\'oh! Terminating script.; exit;
        ;;
esac

mv badFilesRename.sh.txt badFilesRename.sh
./badFilesRename.sh
rm badFilesRename.sh


# DEVELOPMENT NOTES
# Re: http://dimitar.me/quickly-remove-special-characters-from-file-names/
# How to remove the characters ' -~' (everything between those single quote marks) using tr:
# for f in *; do mv "$f" "`echo $f | tr -cd ' -~'`"; done
# Another possibility (maybe not as thorough for removing terminal-unfriendly characters) is::
# tr -dc '[:print:]'

# List of unwanted characters (and a reference bad folder name); with more problematic characters at the start and the problematic minus at the end:
# '@=`~!#$%^&()+[{]};. ,-
# How to figure out which of those need escaping: type them into notepad++ in this saved .sh file; the characters not recognized as part of a string showed in a color other than orange (using the Solarized Dark color scheme), e.g. :
# \`\~\!\@#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\;\'\,\ \.

# Built also with help from:
# http://www.cyberciti.biz/faq/howto-find-a-directory-linux-command/
# Find directories in the current path:
# find * -type d
# I like it but probably re http://stackoverflow.com/a/9612232/1397555 it's problematic [SEE COMMENTS ON THAT POST for an explanation that could potentially make for a far simpler version of this script]:
# for file in "`find . -name "*.txt"`"; do echo "$file"; done
# Re http://stackoverflow.com/a/30911798/1397555

# Example command that WORKS as far as demonstrating replacing characters:
# echo A\`\~\!\@#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\;\'\,\ \.B | tr \`\~\!\@#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\;\'\,\ \. _